from .request import RequestStatus
from .offer import Offer


    #                  HELPER FUNCTIONS
    def _gen_requests(self):
        """Generate new requests using the request generator and add them to the list."""
        new_reqs = self.request_generator.maybe_generate(self.time)
        if new_reqs:
            self.requests.extend(new_reqs)
        return new_reqs

    def _expire_requests(self):
        """Expire requests that have waited longer than timeout."""
        for r in self.requests:
            if r.status == RequestStatus.WAITING and (self.time - r.creation_time) > self.timeout:
                r.mark_expired(self.time)
                self.expired_count += 1

    def _get_proposals(self):
        """Ask the dispatch policy to propose (driver, request) matches."""
        return self.dispatch_policy.assign(self.drivers, self.requests, self.time)

    def _collect_offers(self, proposals):
        """Create offers for drivers and let them decide to accept or reject."""
        offers = []
        for d, r in proposals:
            if r.status != RequestStatus.WAITING:
                continue
            travel_time = d.position.distance_to(r.pickup) / max(d.speed, MIN_SPEED)
            reward = r.pickup.distance_to(r.dropoff)
            off = Offer(d, r, travel_time, reward)
            if d.behaviour and d.behaviour.decide(d, off, self.time):
                offers.append(off)
        return offers

    def _resolve_conflicts(self, offers):
        """Keep only the closest driver per request to avoid conflicts."""
        from collections import defaultdict
        grouped = defaultdict(list)
        for o in offers:
            grouped[o.request.id].append(o)
        final = []
        for same_req in grouped.values():
            same_req.sort(key=lambda o: o.driver.position.distance_to(o.request.pickup))
            final.append(same_req[0])
        return final

    def _assign(self, final):
        """Assign drivers to requests if both are available."""
        for o in final:
            if o.request.status == RequestStatus.WAITING and o.driver.status == "IDLE":
                o.driver.assign_request(o.request, self.time)

    def _move_drivers(self):
        """Move drivers toward their targets and handle pickups/dropoffs."""
        for d in self.drivers:
            if d.status not in ("TO_PICKUP", "TO_DROPOFF"):
                continue
            d.step(1.0)
            tgt = d.target_point()
            if not tgt or d.position.distance_to(tgt) >= EPSILON:
                continue
            if d.status == "TO_PICKUP":
                self._handle_pickup(d)
            else:
                self._handle_dropoff(d)

    def _handle_pickup(self, driver):
        """Complete pickup event for the driver."""
        driver.complete_pickup(self.time)

    def _handle_dropoff(self, driver):
        """Complete dropoff event and update statistics."""
        driver.complete_dropoff(self.time)
        last = driver.history[-1]
        beh = type(driver.behaviour).__name__ if driver.behaviour else "None"
        self.earnings_by_behaviour[beh].append(last.get("fare", 0.0))
        wait = last["time"] - last.get("start_time", last["time"])
        self._wait_samples.append(wait)
        n = len(self._wait_samples)
        self.avg_wait += (wait - self.avg_wait) / n
        self.served_count += 1

    def _mutate(self):
        """Apply mutation rules to drivers (stochastic behavioural drift)."""
        for d in self.drivers:
            self.mutation_rule.maybe_mutate(d, self.time)

    def get_snapshot(self):
        """Return a lightweight state dict for GUI or visualization purposes."""
        return {
            "time": self.time,
            "drivers": [{"id": d.id, "x": d.position.x, "y": d.position.y, "status": d.status} for d in self.drivers],
            "pickups": [{"id": r.id, "x": r.pickup.x, "y": r.pickup.y} for r in self.requests
                        if r.status in (RequestStatus.WAITING, RequestStatus.ASSIGNED)],
            "dropoffs": [{"id": r.id, "x": r.dropoff.x, "y": r.dropoff.y} for r in self.requests
                         if r.status == RequestStatus.PICKED],
            "statistics": {
                "served": self.served_count,
                "expired": self.expired_count,
                "avg_wait": self.avg_wait,
            },
        }
